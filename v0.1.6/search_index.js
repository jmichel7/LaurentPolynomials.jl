var documenterSearchIndex = {"docs":
[{"location":"#Laurent-polynomials","page":"Home","title":"Laurent polynomials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LaurentPolynomials.","category":"page"},{"location":"#LaurentPolynomials.LaurentPolynomials","page":"Home","title":"LaurentPolynomials.LaurentPolynomials","text":"This  package  implements  univariate  Laurent  polynomials, and univariate rational  fractions. The  coefficients can  be in  any ring  (possibly even non-commutative, like Matrix{Int}).\n\nThe  initial  motivation  in  2018  was  to  have  an  easy way to port GAP polynomials  to  Julia.  The  reasons  for  still having my own package are multiple:\n\nI need my  polynomials to  behave  well  when the coefficients are in a ring,  in which  case I use pseudo-division and subresultant gcd.\nI need my polynomials to  work as well as possible with coefficients of type  T where the elements  have a zero method  but T itself does not  have one, because T does  not contain the necessary information. An  example is modular arithmetic with  a BigInt modulus which cannot be  part of the  type. For this  reason the zero  polynomial does not have  an empty list of coefficients,  but a  list containing an element equal  to zero, so it is  always possible to get a  zero of type T from the zero polynomial.\nOften  my polynomials  are several  times  faster  than  those  in  the Polynomials  package.  In  addition,  the  interface  is  simple  and flexible.\nfinally, LaurentPolynomials is designed to work with PuiseuxPolynomials.\n\nThe  only package this  package depends on  is LinearAlgebra, through the use of the exactdiv function.\n\nLaurent  polynomials are of the parametric  type Pol{T}, where T is the type  of  the  coefficients.  They  are  constructed  by giving a vector of coefficients  of type T, and a valuation, an Int; see Pol. We call true polynomials those whose valuation is ≥0.\n\nThere  is  a  \"current  variable  name\"  (a  Symbol)  which  is used when printiing  polynomials nicely at the repl or  in IJulia or Pluto. This name can  be  changed  globally,  or  just  for  printing a specific polynomial. However, polynomials do not individually record which symbol they should be printed with.\n\nExamples\n\njulia> Pol(:q) # define the symbol used for printing and return Pol([1],1)\nPol{Int64}: q\n\njulia> @Pol q  # same as q=Pol(:q)  useful to start a session with polynomials\nPol{Int64}: q\n\njulia> Pol([1,2]) # the valuation is taken to be 0 if omitted\nPol{Int64}: 2q+1\n\njulia> 2q+1       # the same polynomial\nPol{Int64}: 2q+1\n\njulia> Pol()   # omitting all arguments gives Pol([1],1)\nPol{Int64}: q\n\njulia> p=Pol([1,2,1],-1) # here the valuation is specified to be -1\nPol{Int64}: q+2+q⁻¹\n\njulia> q+2+q^-1 # the same polynomial\nPol{Int64}: q+2+q⁻¹\n\njulia> print(p) # for basic printing give an output which Julia can read\nPol([1, 2, 1],-1)\n\n# change the variable used for printing just this time\njulia> print(IOContext(stdout,:limit=>true,:varname=>\"x\"),p)\nx+2+x⁻¹\n\njulia> print(IOContext(stdout,:TeX=>true),p) # TeXable output (used in Pluto, IJulia)\nq+2+q^{-1}\n\nA  polynomial can be  taken apart with  the functions valuation, degree and getindex; p[i] returns the coefficient of degree i of p.\n\njulia> valuation(p),degree(p)\n(-1, 1)\n\njulia> p[0], p[1], p[-1], p[10]\n(2, 1, 1, 0)\n\njulia> p[valuation(p):degree(p)]\n3-element Vector{Int64}:\n 1\n 2\n 1\n\njulia> p[begin:end]  # the same as the above line\n3-element Vector{Int64}:\n 1\n 2\n 1\n\njulia> coefficients(p)  # the same again\n3-element Vector{Int64}:\n 1\n 2\n 1\n\nThe coefficients of a polynomial can come from any ring:\n\njulia> h=Pol([[1 1;0 1],[1 0; 0 1]])\nPol{Matrix{Int64}}: [1 0; 0 1]q+[1 1; 0 1]\n\njulia> h^3\nPol{Matrix{Int64}}: [1 0; 0 1]q³+[3 3; 0 3]q²+[3 6; 0 3]q+[1 3; 0 1]\n\njulia> Pol(1) # convert a number to a scalar polynomial\nPol{Int64}: 1\n\njulia> convert(Pol{Int},1) # the same thing\nPol{Int64}: 1\n\nA  polynomial  is  a  scalar  if  its  valuation  and degree are 0. The scalar function  returns the constant coefficient  if the polynomial is a scalar, and nothing otherwise.\n\njulia> scalar(Pol(1))\n1\n\njulia> convert(Int,Pol(1)) # the same thing\n1\n\njulia> Int(Pol(1))         # the same thing\n1\n\njulia> scalar(q+1) # nothing; convert would give an error\n\nIn arrays Pol{T} of different types T are promoted to the same type T (if  the  T  involved  have  a  promotion)  and a number is promoted to a polynomial.\n\nUsual  arithmetic (+, -,  *, ^, /,  //, one, isone, zero, iszero,  ==) works. Objects  of type <:Number  or of type  T for a Pol{T}   are  considered  as   scalars  for  scalar   operations  on  the coefficients.\n\njulia> derivative(p)\nPol{Int64}: 1-q⁻²\n\njulia> p=(q+1)^2\nPol{Int64}: q²+2q+1\n\njulia> p/2\nPol{Float64}: 0.5q²+1.0q+0.5\n\njulia> p//2\nPol{Rational{Int64}}: (1//2)q²+q+1//2\n\njulia> p(1//2) # value of p at 1//2\n9//4\n\njulia> p(0.5)\n2.25\n\njulia> Pol([1,2,3],[2.0,1.0,3.0])  # Interpolation: find p taking values [2.0,1.0,3.0] at [1,2,3]\nPol{Float64}: 1.5q²-5.5q+6.0\n\nPolynomials  are scalars  for broadcasting.  They can  be sorted (they have cmp   and  isless  functions  which   compare  the  valuation  and  the coefficients), they can be keys in a Dict (they have a hash function).\n\nThe  functions divrem, div, %, gcd, gcdx, lcm,  powermod operate  between true  polynomials over a field, using   the  polynomial  division.  Over  a   ring  it  is  better  to  use pseudodiv  and  srgcd  instead  of divrem and gcd   (by  default  gcd   between  integer  polynomials delegates to srgcd).\n\nLinearAlgebra.exactdiv  does division (over a field or a ring) when it is exact, otherwise gives an error.\n\njulia> divrem(q^3+1,2q+1) # changes coefficients to field elements\n(0.5q²-0.25q+0.125, 0.875)\n\njulia> divrem(q^3+1,2q+1//1) # case of coefficients already field elements\n((1//2)q²+(-1//4)q+1//8, 7//8)\n\njulia> pseudodiv(q^3+1,2q+1) # pseudo-division keeps the ring\n(4q²-2q+1, 7)\n\njulia> (4q^2-2q+1)*(2q+1)+7 # but multiplying back gives a multiple of the polynomial\nPol{Int64}: 8q³+8\n\njulia> LinearAlgebra.exactdiv(q+1,2.0) # LinearAlgebra.exactdiv(q+1,Pol(2)) would give an error\nPol{Float64}: 0.5q+0.5\n\njulia> LinearAlgebra.exactdiv(q^2-1,q+1)\nPol{Int64}: q-1\n\njulia> LinearAlgebra.exactdiv(q-1,q+1)\nERROR: Pol([1, 1]) does not exactly divide Pol([-1, 1])\nStacktrace:\n [1] error(::Pol{Int64}, ::String, ::Pol{Int64})\n   @ Base ./error.jl:44\n [2] exactdiv(a::Pol{Int64}, b::Pol{Int64})\n   @ LaurentPolynomials ~/.julia/dev/LaurentPolynomials/src/LaurentPolynomials.jl:600\n [3] top-level scope\n   @ REPL[14]:1\n\nFinally,   Pols  have   methods  conj,   adjoint  which   operate  on coefficients,  methods positive_part, negative_part and bar   (useful   for   Kazhdan-Lusztig   theory)   and   a  method randpol  to produce random polynomials. There are also methods to compute the resultant of two polynomials and the discriminant of a polynomial.\n\nInverting  polynomials is a way to  get a rational fraction Frac{Pol{T}}, where  Frac  is  a  general  type  for  fractions. Rational fractions are normalised  so that the numerator and denominator are true polynomials that are  prime to each  other. They have  the arithmetic operations  +, - , *,  /, //,  ^, inv,  one, isone,  zero, iszero (which can operate between a Pol or a Number and a Frac{Pol{T}}).\n\njulia> a=1/(q+1)\nFrac{Pol{Int64}}: 1/(q+1)\n\njulia> Pol(2/a) # convert back to `Pol`\nPol{Int64}: 2q+2\n\njulia> numerator(a)\nPol{Int64}: 1\n\njulia> denominator(a)\nPol{Int64}: q+1\n\njulia> m=[q+1 q+2;q-2 q-3]\n2×2 Matrix{Pol{Int64}}:\n q+1  q+2\n q-2  q-3\n\njulia> n=inv(Frac.(m)) # convert to rational fractions to invert the matrix\n2×2 Matrix{Frac{Pol{Int64}}}:\n (-q+3)/(2q-1)  (-q-2)/(-2q+1)\n (q-2)/(2q-1)   (q+1)/(-2q+1)\n\njulia> map(x->x(1),n) # evaluate at 1 the inverse matrix\n2×2 Matrix{Float64}:\n  2.0   3.0\n -1.0  -2.0\n\njulia> map(x->x(1;Rational=true),n) # evaluate at 1 using //\n2×2 Matrix{Rational{Int64}}:\n  2   3\n -1  -2\n\nRational fractions are also scalars for broadcasting and can be sorted (have cmp and isless methods).\n\n\n\n\n\n","category":"module"},{"location":"#LaurentPolynomials.Pol","page":"Home","title":"LaurentPolynomials.Pol","text":"Pol(c::AbstractVector,v::Integer=0;check=true,copy=true)\n\nMake a polynomial of valuation v with coefficients c.\n\nThen,  unless check is  false normalize the  result by making sure that c  has no leading or trailing zeroes (do not set check=false unless you are sure this is already the case).\n\nUnless  copy=false  the  contents  of  c  are  copied (you can gain one allocation by setting copy=false if you know the contents can be shared)\n\n\n\n\n\nPol(t::Symbol)\n\nSets  the name of the variable for  printing Pols to t, and returns the polynomial Pol([1],1).\n\n\n\n\n\nPol(x::AbstractVector,y::AbstractVector)\n\nInterpolation:  find a Pol (of  nonnegative valuation) of smallest degree taking  values y at points  x. The values y  should be in a field for the function to be type stable.\n\njulia> p=Pol([1,1,1])\nPol{Int64}: q²+q+1\n\njulia> vals=p.(1:5)\n5-element Vector{Int64}:\n  3\n  7\n 13\n 21\n 31\n\njulia> Pol(1:5,vals*1//1)\nPol{Rational{Int64}}: q²+q+1\n\njulia> Pol(1:5,vals*1.0)\nPol{Float64}: 1.0q²+1.0q+1.0\n\n\n\n\n\n","category":"type"},{"location":"#LaurentPolynomials.@Pol","page":"Home","title":"LaurentPolynomials.@Pol","text":"@Pol q\n\nis equivalent to q=Pol(:q) except that it creates q in the global scope of the current module, since it uses eval.\n\n\n\n\n\n","category":"macro"},{"location":"#Base.divrem","page":"Home","title":"Base.divrem","text":"divrem(a::Pol, b::Pol)\n\na  and b  should be  true polynomials  (have a  nonnegative valuation). Computes  (q,r) such that a=q*b+r and degree(r)<degree(b). It is type stable if the coefficients of b are in a field.\n\n\n\n\n\n","category":"function"},{"location":"#Base.gcd-Tuple{Pol, Pol}","page":"Home","title":"Base.gcd","text":"gcd(p::Pol,  q::Pol) computes the  gcd of the  polynomials. It uses the subresultant algorithms for the gcd of integer polynomials.\n\njulia> gcd(2q+2,2q^2-2)\nPol{Int64}: 2q+2\n\njulia> gcd((2q+2)//1,(2q^2-2)//1)\nPol{Rational{Int64}}: q+1\n\n\n\n\n\n","category":"method"},{"location":"#Base.gcdx-Tuple{Pol, Pol}","page":"Home","title":"Base.gcdx","text":"gcdx(a::Pol,b::Pol) \n\nfor  polynomials  over  a  field  returns d,u,v  such  that d=ua+vb and d=gcd(a,b).\n\njulia> gcdx(q^3-1//1,q^2-1//1)\n(q-1, 1, -q)\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.pseudodiv","page":"Home","title":"LaurentPolynomials.pseudodiv","text":"pseudodiv(a::Pol, b::Pol)\n\npseudo-division  of a by b.  If d is the  leading coefficient of b, computes   (q,r)   such   that   d^(degree(a)+1-degree(b))a=q*b+r   and degree(r)<degree(b). Does not do division so works over any ring. For true polynomials (errors if the valuation of a or of b is negative).\n\njulia> pseudodiv(q^2+1,2q+1)\n(2q-1, 5)\n\njulia> (2q+1)*(2q-1)+5\nPol{Int64}: 4q²+4\n\nSee Knuth AOCP2 4.6.1 Algorithm R\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.srgcd","page":"Home","title":"LaurentPolynomials.srgcd","text":"srgcd(a::Pol,b::Pol)\n\nsub-resultant gcd: gcd of polynomials over a unique factorization domain\n\njulia> srgcd(4q+4,6q^2-6)\nPol{Int64}: 2q+2\n\nSee Knuth AOCP2 4.6.1 Algorithm C\n\n\n\n\n\n","category":"function"},{"location":"#Base.powermod","page":"Home","title":"Base.powermod","text":"powermod(p::Pol, x::Integer, q::Pol) computes p^x pmod m.\n\njulia> powermod(q-1//1,3,q^2+q+1)\nPol{Rational{Int64}}: 6q+3\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.randpol","page":"Home","title":"LaurentPolynomials.randpol","text":"randpol(T,d)\n\npolynomial of degree d with random coefficients from T\n\njulia> randpol(-1:1,7)\nPol{Int64}: -q⁷+q⁶-q⁵-q⁴+q²+1\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.Frac","page":"Home","title":"LaurentPolynomials.Frac","text":"`Frac(a::Pol,b::Pol;prime=false)\n\nMakes  the  rational  fraction  with  numerator  a  and  denominator b. Polynomials  a and  b are  promoted to  the same  coefficient type, and checked  for being true polynomials (otherwise  they are both multiplied by the  same power  of Pol()  so they  become true  polynomials), and unless prime=true they are both divided by a non-trivial common gcd.\n\njulia> Frac(q^2+q,q^3-q)\nFrac{Pol{Int64}}: 1/(q-1)\n\n\n\n\n\n","category":"type"},{"location":"#LaurentPolynomials.negative_part","page":"Home","title":"LaurentPolynomials.negative_part","text":"negative_part(p::Pol) keep the terms of degree≤0\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.positive_part","page":"Home","title":"LaurentPolynomials.positive_part","text":"positive_part(p::Pol) keep the terms of degree≥0\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.bar","page":"Home","title":"LaurentPolynomials.bar","text":"bar(p::Pol) transform p(q) into p(q⁻¹)\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.shift","page":"Home","title":"LaurentPolynomials.shift","text":"shift(p::Pol,s) is an efficient way to multiply p by Pol()^s.\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.resultant","page":"Home","title":"LaurentPolynomials.resultant","text":"resultant(p::Pol,q::Pol)\n\nThe  function  computes  the  resultant  of  the  two  polynomials,  as the determinant of the Sylvester matrix.\n\njulia> resultant(q^3+q+1,derivative(q^3+q+1))\n31\n\n\n\n\n\n","category":"function"},{"location":"#LaurentPolynomials.discriminant","page":"Home","title":"LaurentPolynomials.discriminant","text":"discriminant(p::Pol) \n\nis  the  resultant  of  the  polynomial  with  its derivative. This detects multiple zeroes.\n\njulia> discriminant(q^3+q+1)\n31\n\n\n\n\n\n","category":"function"}]
}
