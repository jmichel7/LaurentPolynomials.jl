<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LaurentPolynomials.jl</title><meta name="title" content="Home · LaurentPolynomials.jl"/><meta property="og:title" content="Home · LaurentPolynomials.jl"/><meta property="twitter:title" content="Home · LaurentPolynomials.jl"/><meta name="description" content="Documentation for LaurentPolynomials.jl."/><meta property="og:description" content="Documentation for LaurentPolynomials.jl."/><meta property="twitter:description" content="Documentation for LaurentPolynomials.jl."/><meta property="og:url" content="https://jmichel7.github.io/LaurentPolynomials.jl/"/><meta property="twitter:url" content="https://jmichel7.github.io/LaurentPolynomials.jl/"/><link rel="canonical" href="https://jmichel7.github.io/LaurentPolynomials.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LaurentPolynomials.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/LaurentPolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Laurent-polynomials"><a class="docs-heading-anchor" href="#Laurent-polynomials">Laurent polynomials</a><a id="Laurent-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Laurent-polynomials" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jmichel7/LaurentPolynomials.jl">LaurentPolynomials</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.LaurentPolynomials" href="#LaurentPolynomials.LaurentPolynomials"><code>LaurentPolynomials.LaurentPolynomials</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This  package  implements  univariate  Laurent  polynomials, and univariate rational  fractions. The  coefficients can  be in  any ring  (possibly even non-commutative, like <code>Matrix{Int}</code>).</p><p>The  initial  motivation  in  2018  was  to  have  an  easy way to port GAP polynomials  to  Julia.  The  reasons  for  still having my own package are multiple:</p><ul><li>I need my  polynomials to  behave  well  when the coefficients are in a ring,  in which  case I use pseudo-division and subresultant gcd.</li><li>I need my polynomials to  work as well as possible with coefficients of type  <code>T</code> where the elements  have a <code>zero</code> method  but <code>T</code> itself does not  have one, because <code>T</code> does  not contain the necessary information. An  example is modular arithmetic with  a <code>BigInt</code> modulus which cannot be  part of the  type. For this  reason the <code>zero</code>  polynomial does not have  an empty list of coefficients,  but a  list containing an element equal  to zero, so it is  always possible to get a  zero of type T from the zero polynomial.</li><li>Often  my polynomials  are several  times  faster  than  those  in  the <code>Polynomials</code>  package.  In  addition,  the  interface  is  simple  and flexible.</li><li>finally, <code>LaurentPolynomials</code> is designed to work with <code>PuiseuxPolynomials</code>.</li></ul><p>The  only package this  package depends on  is <code>LinearAlgebra</code>, through the use of the <code>exactdiv</code> function.</p><p>Laurent  polynomials are of the parametric  type <code>Pol{T}</code>, where <code>T</code> is the type  of  the  coefficients.  They  are  constructed  by giving a vector of coefficients  of type <code>T</code>, and a valuation, an <code>Int</code>; see <a href="#LaurentPolynomials.Pol"><code>Pol</code></a>. We call true polynomials those whose valuation is <code>≥0</code>.</p><p>There  is  a  &quot;current  variable  name&quot;  (a  <code>Symbol</code>)  which  is used when printiing  polynomials nicely at the repl or  in IJulia or Pluto. This name can  be  changed  globally,  or  just  for  printing a specific polynomial. However, polynomials do not individually record which symbol they should be printed with.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Pol(:q) # define the symbol used for printing and return Pol([1],1)
Pol{Int64}: q

julia&gt; @Pol q  # same as q=Pol(:q)  useful to start a session with polynomials
Pol{Int64}: q

julia&gt; Pol([1,2]) # the valuation is taken to be 0 if omitted
Pol{Int64}: 2q+1

julia&gt; 2q+1       # the same polynomial
Pol{Int64}: 2q+1

julia&gt; Pol()   # omitting all arguments gives Pol([1],1)
Pol{Int64}: q

julia&gt; p=Pol([1,2,1],-1) # here the valuation is specified to be -1
Pol{Int64}: q+2+q⁻¹

julia&gt; q+2+q^-1 # the same polynomial
Pol{Int64}: q+2+q⁻¹</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; print(p) # for basic printing give an output which Julia can read
Pol([1, 2, 1],-1)

# change the variable used for printing just this time
julia&gt; print(IOContext(stdout,:limit=&gt;true,:varname=&gt;&quot;x&quot;),p)
x+2+x⁻¹

julia&gt; print(IOContext(stdout,:TeX=&gt;true),p) # TeXable output (used in Pluto, IJulia)
q+2+q^{-1}</code></pre><p>A  polynomial can be  taken apart with  the functions <code>valuation</code>, <code>degree</code> and <code>getindex</code>; <code>p[i]</code> returns the coefficient of degree <code>i</code> of <code>p</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; valuation(p),degree(p)
(-1, 1)

julia&gt; p[0], p[1], p[-1], p[10]
(2, 1, 1, 0)

julia&gt; p[valuation(p):degree(p)]
3-element Vector{Int64}:
 1
 2
 1

julia&gt; p[begin:end]  # the same as the above line
3-element Vector{Int64}:
 1
 2
 1

julia&gt; coefficients(p)  # the same again
3-element Vector{Int64}:
 1
 2
 1</code></pre><p>The coefficients of a polynomial can come from any ring:</p><pre><code class="language-julia-repl hljs">julia&gt; h=Pol([[1 1;0 1],[1 0; 0 1]])
Pol{Matrix{Int64}}: [1 0; 0 1]q+[1 1; 0 1]

julia&gt; h^3
Pol{Matrix{Int64}}: [1 0; 0 1]q³+[3 3; 0 3]q²+[3 6; 0 3]q+[1 3; 0 1]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Pol(1) # convert a number to a scalar polynomial
Pol{Int64}: 1

julia&gt; convert(Pol{Int},1) # the same thing
Pol{Int64}: 1</code></pre><p>A  polynomial  is  a  <em>scalar</em>  if  its  valuation  and degree are <code>0</code>. The <code>scalar</code> function  returns the constant coefficient  if the polynomial is a scalar, and <code>nothing</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; scalar(Pol(1))
1

julia&gt; convert(Int,Pol(1)) # the same thing
1

julia&gt; Int(Pol(1))         # the same thing
1

julia&gt; scalar(q+1) # nothing; convert would give an error</code></pre><p>In arrays <code>Pol{T}</code> of different types <code>T</code> are promoted to the same type <code>T</code> (if  the  <code>T</code>  involved  have  a  promotion)  and a number is promoted to a polynomial.</p><p>Usual  arithmetic (<code>+</code>, <code>-</code>,  <code>*</code>, <code>^</code>, <code>/</code>,  <code>//</code>, <code>one</code>, <code>isone</code>, <code>zero</code>, <code>iszero</code>,  <code>==</code>) works. Objects  of type <code>&lt;:Number</code>  or of type  <code>T</code> for a <code>Pol{T}</code>   are  considered  as   scalars  for  scalar   operations  on  the coefficients.</p><pre><code class="language-julia-repl hljs">julia&gt; derivative(p)
Pol{Int64}: 1-q⁻²

julia&gt; p=(q+1)^2
Pol{Int64}: q²+2q+1

julia&gt; p/2
Pol{Float64}: 0.5q²+1.0q+0.5

julia&gt; p//2
Pol{Rational{Int64}}: (1//2)q²+q+1//2

julia&gt; p(1//2) # value of p at 1//2
9//4

julia&gt; p(0.5)
2.25

julia&gt; Pol([1,2,3],[2.0,1.0,3.0])  # Interpolation: find p taking values [2.0,1.0,3.0] at [1,2,3]
Pol{Float64}: 1.5q²-5.5q+6.0</code></pre><p>Polynomials  are scalars  for broadcasting.  They can  be sorted (they have <code>cmp</code>   and  <code>isless</code>  functions  which   compare  the  valuation  and  the coefficients), they can be keys in a <code>Dict</code> (they have a <code>hash</code> function).</p><p>The  functions <a href="#Base.divrem"><code>divrem</code></a>, <code>div</code>, <code>%</code>, <a href="#Base.gcd-Tuple{Pol, Pol}"><code>gcd</code></a>, <a href="#Base.gcdx-Tuple{Pol, Pol}"><code>gcdx</code></a>, <code>lcm</code>,  <a href="#Base.powermod"><code>powermod</code></a> operate  between true  polynomials over a field, using   the  polynomial  division.  Over  a   ring  it  is  better  to  use <a href="#LaurentPolynomials.pseudodiv"><code>pseudodiv</code></a>  and  <a href="#LaurentPolynomials.srgcd"><code>srgcd</code></a>  instead  of <a href="#Base.divrem"><code>divrem</code></a> and <a href="#Base.gcd-Tuple{Pol, Pol}"><code>gcd</code></a>   (by  default  <a href="#Base.gcd-Tuple{Pol, Pol}"><code>gcd</code></a>   between  integer  polynomials delegates to <a href="#LaurentPolynomials.srgcd"><code>srgcd</code></a>).</p><p><code>LinearAlgebra.exactdiv</code>  does division (over a field or a ring) when it is exact, otherwise gives an error.</p><pre><code class="language-julia-repl hljs">julia&gt; divrem(q^3+1,2q+1) # changes coefficients to field elements
(0.5q²-0.25q+0.125, 0.875)

julia&gt; divrem(q^3+1,2q+1//1) # case of coefficients already field elements
((1//2)q²+(-1//4)q+1//8, 7//8)

julia&gt; pseudodiv(q^3+1,2q+1) # pseudo-division keeps the ring
(4q²-2q+1, 7)

julia&gt; (4q^2-2q+1)*(2q+1)+7 # but multiplying back gives a multiple of the polynomial
Pol{Int64}: 8q³+8

julia&gt; LinearAlgebra.exactdiv(q+1,2.0) # LinearAlgebra.exactdiv(q+1,Pol(2)) would give an error
Pol{Float64}: 0.5q+0.5

julia&gt; LinearAlgebra.exactdiv(q^2-1,q+1)
Pol{Int64}: q-1</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; LinearAlgebra.exactdiv(q-1,q+1)
ERROR: Pol([1, 1]) does not exactly divide Pol([-1, 1])
Stacktrace:
 [1] error(::Pol{Int64}, ::String, ::Pol{Int64})
   @ Base ./error.jl:44
 [2] exactdiv(a::Pol{Int64}, b::Pol{Int64})
   @ LaurentPolynomials ~/.julia/dev/LaurentPolynomials/src/LaurentPolynomials.jl:600
 [3] top-level scope
   @ REPL[14]:1</code></pre><p>Finally,   <code>Pol</code>s  have   methods  <code>conj</code>,   <code>adjoint</code>  which   operate  on coefficients,  methods <a href="#LaurentPolynomials.positive_part"><code>positive_part</code></a>, <a href="#LaurentPolynomials.negative_part"><code>negative_part</code></a> and <a href="#LaurentPolynomials.bar"><code>bar</code></a>   (useful   for   Kazhdan-Lusztig   theory)   and   a  method <a href="#LaurentPolynomials.randpol"><code>randpol</code></a>  to produce random polynomials. There are also methods to compute the <a href="#LaurentPolynomials.resultant"><code>resultant</code></a> of two polynomials and the <a href="#LaurentPolynomials.discriminant"><code>discriminant</code></a> of a polynomial.</p><p>Inverting  polynomials is a way to  get a rational fraction <code>Frac{Pol{T}}</code>, where  <code>Frac</code>  is  a  general  type  for  fractions. Rational fractions are normalised  so that the numerator and denominator are true polynomials that are  prime to each  other. They have  the arithmetic operations  <code>+</code>, <code>-</code> , <code>*</code>,  <code>/</code>, <code>//</code>,  <code>^</code>, <code>inv</code>,  <code>one</code>, <code>isone</code>,  <code>zero</code>, <code>iszero</code> (which can operate between a <code>Pol</code> or a <code>Number</code> and a <code>Frac{Pol{T}}</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; a=1/(q+1)
Frac{Pol{Int64}}: 1/(q+1)

julia&gt; Pol(2/a) # convert back to `Pol`
Pol{Int64}: 2q+2

julia&gt; numerator(a)
Pol{Int64}: 1

julia&gt; denominator(a)
Pol{Int64}: q+1

julia&gt; m=[q+1 q+2;q-2 q-3]
2×2 Matrix{Pol{Int64}}:
 q+1  q+2
 q-2  q-3

julia&gt; n=inv(Frac.(m)) # convert to rational fractions to invert the matrix
2×2 Matrix{Frac{Pol{Int64}}}:
 (-q+3)/(2q-1)  (-q-2)/(-2q+1)
 (q-2)/(2q-1)   (q+1)/(-2q+1)

julia&gt; map(x-&gt;x(1),n) # evaluate at 1 the inverse matrix
2×2 Matrix{Float64}:
  2.0   3.0
 -1.0  -2.0

julia&gt; map(x-&gt;x(1;Rational=true),n) # evaluate at 1 using //
2×2 Matrix{Rational{Int64}}:
  2   3
 -1  -2</code></pre><p>Rational fractions are also scalars for broadcasting and can be sorted (have <code>cmp</code> and <code>isless</code> methods).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L1-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.Pol" href="#LaurentPolynomials.Pol"><code>LaurentPolynomials.Pol</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Pol(c::AbstractVector,v::Integer=0;check=true,copy=true)</code></p><p>Make a polynomial of valuation <code>v</code> with coefficients <code>c</code>.</p><p>Then,  unless <code>check</code> is  <code>false</code> normalize the  result by making sure that <code>c</code>  has no leading or trailing zeroes (do not set <code>check=false</code> unless you are sure this is already the case).</p><p>Unless  <code>copy=false</code>  the  contents  of  <code>c</code>  are  copied (you can gain one allocation by setting <code>copy=false</code> if you know the contents can be shared)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L281-L292">source</a></section><section><div><p><code>Pol(t::Symbol)</code></p><p>Sets  the name of the variable for  printing <code>Pol</code>s to <code>t</code>, and returns the polynomial <code>Pol([1],1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L310-L315">source</a></section><section><div><p><code>Pol(x::AbstractVector,y::AbstractVector)</code></p><p>Interpolation:  find a <code>Pol</code> (of  nonnegative valuation) of smallest degree taking  values <code>y</code> at points  <code>x</code>. The values <code>y</code>  should be in a field for the function to be type stable.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Pol([1,1,1])
Pol{Int64}: q²+q+1

julia&gt; vals=p.(1:5)
5-element Vector{Int64}:
  3
  7
 13
 21
 31

julia&gt; Pol(1:5,vals*1//1)
Pol{Rational{Int64}}: q²+q+1

julia&gt; Pol(1:5,vals*1.0)
Pol{Float64}: 1.0q²+1.0q+1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L796-L821">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.@Pol" href="#LaurentPolynomials.@Pol"><code>LaurentPolynomials.@Pol</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>@Pol q</code></p><p>is equivalent to <code>q=Pol(:q)</code> except that it creates <code>q</code> in the global scope of the current module, since it uses <code>eval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L321-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>divrem(a::Pol, b::Pol)</code></p><p><code>a</code>  and <code>b</code>  should be  true polynomials  (have a  nonnegative valuation). Computes  <code>(q,r)</code> such that <code>a=q*b+r</code> and <code>degree(r)&lt;degree(b)</code>. It is type stable if the coefficients of <code>b</code> are in a field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L573-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.gcd-Tuple{Pol, Pol}" href="#Base.gcd-Tuple{Pol, Pol}"><code>Base.gcd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>gcd(p::Pol,  q::Pol)</code> computes the  <code>gcd</code> of the  polynomials. It uses the subresultant algorithms for the <code>gcd</code> of integer polynomials.</p><pre><code class="language-julia-repl hljs">julia&gt; gcd(2q+2,2q^2-2)
Pol{Int64}: 2q+2

julia&gt; gcd((2q+2)//1,(2q^2-2)//1)
Pol{Rational{Int64}}: q+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L710-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.gcdx-Tuple{Pol, Pol}" href="#Base.gcdx-Tuple{Pol, Pol}"><code>Base.gcdx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>gcdx(a::Pol,b::Pol)</code> </p><p>for  polynomials  over  a  field  returns <code>d,u,v</code>  such  that <code>d=ua+vb</code> and <code>d=gcd(a,b)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; gcdx(q^3-1//1,q^2-1//1)
(q-1, 1, -q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L734-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.pseudodiv" href="#LaurentPolynomials.pseudodiv"><code>LaurentPolynomials.pseudodiv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>pseudodiv(a::Pol, b::Pol)</code></p><p>pseudo-division  of <code>a</code> by <code>b</code>.  If <code>d</code> is the  leading coefficient of <code>b</code>, computes   <code>(q,r)</code>   such   that   <code>d^(degree(a)+1-degree(b))a=q*b+r</code>   and <code>degree(r)&lt;degree(b)</code>. Does not do division so works over any ring. For true polynomials (errors if the valuation of <code>a</code> or of <code>b</code> is negative).</p><pre><code class="language-julia-repl hljs">julia&gt; pseudodiv(q^2+1,2q+1)
(2q-1, 5)

julia&gt; (2q+1)*(2q-1)+5
Pol{Int64}: 4q²+4</code></pre><p>See Knuth AOCP2 4.6.1 Algorithm R</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L620-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.srgcd" href="#LaurentPolynomials.srgcd"><code>LaurentPolynomials.srgcd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>srgcd(a::Pol,b::Pol)</code></p><p>sub-resultant gcd: gcd of polynomials over a unique factorization domain</p><pre><code class="language-julia-repl hljs">julia&gt; srgcd(4q+4,6q^2-6)
Pol{Int64}: 2q+2</code></pre><p>See Knuth AOCP2 4.6.1 Algorithm C</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L659-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.powermod" href="#Base.powermod"><code>Base.powermod</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>powermod(p::Pol, x::Integer, q::Pol)</code> computes <span>$p^x \pmod m$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; powermod(q-1//1,3,q^2+q+1)
Pol{Rational{Int64}}: 6q+3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L761-L767">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.randpol" href="#LaurentPolynomials.randpol"><code>LaurentPolynomials.randpol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>randpol(T,d)</code></p><p>polynomial of degree <code>d</code> with random coefficients from <code>T</code></p><pre><code class="language-julia-rep1 hljs">julia&gt; randpol(-1:1,7)
Pol{Int64}: -q⁷+q⁶-q⁵-q⁴+q²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L785-L793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.Frac" href="#LaurentPolynomials.Frac"><code>LaurentPolynomials.Frac</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>`Frac(a::Pol,b::Pol;prime=false)</p><p>Makes  the  rational  fraction  with  numerator  <code>a</code>  and  denominator <code>b</code>. Polynomials  <code>a</code> and  <code>b</code> are  promoted to  the same  coefficient type, and checked  for being true polynomials (otherwise  they are both multiplied by the  same power  of <code>Pol()</code>  so they  become true  polynomials), and unless <code>prime=true</code> they are both divided by a non-trivial common <code>gcd</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Frac(q^2+q,q^3-q)
Frac{Pol{Int64}}: 1/(q-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L993-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.negative_part" href="#LaurentPolynomials.negative_part"><code>LaurentPolynomials.negative_part</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>negative_part(p::Pol)</code> keep the terms of degree≤0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.positive_part" href="#LaurentPolynomials.positive_part"><code>LaurentPolynomials.positive_part</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>positive_part(p::Pol)</code> keep the terms of degree≥0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.bar" href="#LaurentPolynomials.bar"><code>LaurentPolynomials.bar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>bar(p::Pol)</code> transform p(q) into p(q⁻¹)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.shift" href="#LaurentPolynomials.shift"><code>LaurentPolynomials.shift</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>shift(p::Pol,s)</code> is an efficient way to multiply <code>p</code> by <code>Pol()^s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L386-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.resultant" href="#LaurentPolynomials.resultant"><code>LaurentPolynomials.resultant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>resultant(p::Pol,q::Pol)</code></p><p>The  function  computes  the  resultant  of  the  two  polynomials,  as the determinant of the Sylvester matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; resultant(q^3+q+1,derivative(q^3+q+1))
31</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L851-L860">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LaurentPolynomials.discriminant" href="#LaurentPolynomials.discriminant"><code>LaurentPolynomials.discriminant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>discriminant(p::Pol)</code> </p><p>is  the  resultant  of  the  polynomial  with  its derivative. This detects multiple zeroes.</p><pre><code class="language-julia-repl hljs">julia&gt; discriminant(q^3+q+1)
31</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/LaurentPolynomials.jl/blob/78f1ddfaec0be22a91bcdc6c5b4a82d831a1bb9f/src/LaurentPolynomials.jl#L871-L880">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 11 November 2025 23:04">Tuesday 11 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
